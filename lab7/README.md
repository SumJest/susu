# Отчет о лабораторной работе №7
## Задачи
Все задачи взяты [отсюда](https://informatics.msk.ru/mod/statements/view.php?id=26736&chapterid=113659 "отсюда") 

Тематика задач - Форум. Действия с сообщениями 

Для удобства написан модуль [forum.py](https://github.com/SumJest/susu/blob/b7c49f21be0e3a3c23b41ac64595ead059896cb6/lab7/modules/forum.py "forum.py") в нем прописаны все необходимые функции для работы с сообщениями

##### Задачи:
1. [Форум. Удаление ветви](https://github.com/SumJest/susu/tree/b7c49f21be0e3a3c23b41ac64595ead059896cb6/lab7/task1 "Форум. Удаление ветви")
2. [Форум. Вывести путь](https://github.com/SumJest/susu/tree/b7c49f21be0e3a3c23b41ac64595ead059896cb6/lab7/task2 "Форум. Вывести путь")
3. [Форум. Вывести дерево](https://github.com/SumJest/susu/tree/b7c49f21be0e3a3c23b41ac64595ead059896cb6/lab7/task3 "Форум. Вывести дерево")

Для удобства проверки можно использовать следующий ввод для инициализации форума:

```
15
1 0
2 0
3 1
4 3
6 3
8 4
9 4
7 6
5 2
10 5
11 5
12 11
13 11
14 11
15 12
```

При использовании этого ввода структура будет выглядить следующим образом: 

[![Структура](https://i.imgur.com/sY5quH3.png "Структура")](https://imgur.com/sY5quH3 "Структура")

------------


## Контрольные вопросы

**1. Что такое рекурсивная подпрограмма?**

Рекурсивная подпрограмма - подпрограмма, которая вызывает сама себя.

**2. Что такое итерация?**

Итерация - один проход (повторение) цикла.

**3. Что такое стек? Каким образом стек используется при реализации рекурсии?**
Стек - хранилище данных, в который можно заносить данные только **"снизу-вверх"** и соответственно брать их **"сверху-вниз"**.  Можно провести аналогию с коробкой. Вещи мы складываем в нее попорядку снизу-вверх. А когда нам нужно их достать, мы можем только брать самые верхние.

Стек - это так же область оперативной памяти, предназначенная для программ, их функций и переменных. При запуске программы, все необходимые данные записываются в стек, а при выполнении достаются с конца. Поэтому в языках по типу c/c++, мы не можем инициализировать переменные с заранее неизвестным объемом данных. Для таких задач используется "Куча".

Выполнение рекурсивных функций это отличный пример стека. Каждый новый вызов функции становится "поверх" предыдущего. И функции завершают своё выполнение начиная с самой последней до самой первой.

**4. Составьте рекурсивный и итерационный алгоритмы нахождения N!**

Рекурсивный:

```python
def factorial(n: int) -> int:
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```
Итерационный:

```python
def factorial(n: int) -> int:
    fact = 1
    for i in range(n, 1, -1):
        fact *= i
    return fact
```

**5. Объясните термин "косвенная рекурсия"?**

Косвенная рекурсия - это способ выполнения функции, при котором функции внутри вызывают друг-друга.

Пример:
```python
def f(n):
    if n > 0:
        g(n - 1)

def g(n):
    print(n)

    if n > 1:
        f(n - 2)
```

**6. Если эффективность алгоритмов оценивать по количеству операторов присваивания, то, как вы думаете, какой алгоритм (рекурсивный или итерационный) будет наиболее эффективен? Обоснуйте на примере вычисления значений многочлена Лагранжа:**

[![Ланграж](http://zns.susu.ru/images/lab3-31.gif "Ланграж")](http://zns.susu.ru/images/lab3-31.gif "Ланграж")

```python
def rec_p(x, n):
    print(1)
    if n == 1:
        return x
    elif n == 0:
        return 1
    a = rec_p(x, n - 1) * x * (2 * n + 1) / (n + 1) - rec_p(x, n - 2) * n / (n + 1)
    return a


def it_p(x, n):
    p1 = 1
    p2 = x
    count = 2
    for i in range(2, n + 1):
        p1 = p2 * x * (2 * i + 1) / (i + 1) - p1 * i / (i + 1)
        b = p1
        p1 = p2
        p2 = b
        count += 4
    print(count)
    return p2


print(rec_p(5, 7))
print(it_p(5, 7))

```
Вывод:
```
1
... }41
1
2447138.8571428573
26
2447138.8571428573
```

Оценка итерационного алгоритма предельна проста **2** оператора присваивание в самом начале. И на каждую итерацию приходится по **4** оператора. Количество операторов присвивания **(2 + 4n)**, то есть сложность  **O(N)**.

С рекурсивным по-сложнее. Каждый вызов функции это **1** оператор присваивания. Но каждая функция в себе вызывает ещё две. Соответветственно сложность данного алгоритма **O(2^N)** 

Итерационный алгоритм **эффективней**. 

Для наглядности:
```python
print(rec_p(5, 20))
print(it_p(5, 20))
```
Вывод:
```
1
... }21891
1
1.3361992451947833e+19
78
1.3361992451947833e+19
```
Рекурсивный - **21891** операторов, итерационный - **78** операторов