# Отчет о лабораторной работе №8

**Вариант: ** 3
**Алгоритмы сортировки: **
1. [Пузырьком](https://github.com/SumJest/susu/blob/master/lab8/sorts.py#L43 "Пузырьком")
2. [Слиянием](https://github.com/SumJest/susu/blob/master/lab8/sorts.py#L57 "Слиянием")
3. [Быстрая](https://github.com/SumJest/susu/blob/master/lab8/sorts.py#L70 "Быстрая")

**Нюансы с быстрой сортировкой. **
Выбор опорной точки производится по случайному элементу, по моему мнению это эффективней, чем брать элемент посереди. В случае если последовательность специально заготовлена, это снижает вероятность перегрузки.
Я в ней не стал использовать написанную команду swap, так как при количестве
элементов списка **200.000** использование внешней функции замедляло сортировку в среднем на **~0.2** секунды.
Так же я заметил, что использование функции `random.choice()` сильно замедляло сортировку.
*(~0.2 секунды при 240 элементах, это в ~13 раз больше чем сортировка пузырьком)*

Так же использование множественного присваивания для обмена элементов, сократило время сортировки на **~0.1** секунду
при **200.000** элементах *(для генерации последовательности использовался один сид).*

Результаты тестов:

Использование множественного присваивания: **~2.59292 сек**


Использование буферной переменной: **~2.67272 сек**


Так же увеличивает время проверка переданных начальной и конечной позиций для первого вызова сортировки.

### Результаты работы программы

**Результаты при 10000 элементах:**

[![10kbench](https://i.imgur.com/m0CcVX0.png "10kbench")](https://imgur.com/a/3ez4L2q "10kbench")

**Результаты при 200.000 элементах (без пузырька, т.к. это заняло бы порядка ~5.74 часов на только инвертированную):**

[![200kbench](https://i.imgur.com/CFtWaOJ.png "200kbench")](https://imgur.com/a/3ez4L2q "200kbench")

### Анализ
Самый медленный и неэффективный алгоритм сортировки - пузырьком со
временем **O(n&sup2;)** и памятью **O(1)**.
Самая быстрая сортировка, это соответственно быстрая, но время и память зависит от выбора опорной точки, но сильное увеление времени маловероятно, если последовательность не специально заготовлена.
Медленнее работает сортировка слиянием, хотя она в отличии у нее нет зависимости от случайности.
В среднем время выполнение этих сортировок - **O(n&middot;logn)**,
Но в связи с рекурсивностью память - **O(n&middot;logn)** у быстрой и **O(n)** у слиянием

------------


## Контрольные вопросы

**1. Дайте определение термину "внутренняя сортировка"?**

Это сортировка с использованием только оперативной памяти, без сохранения частей сортируемого массива в постоянную.

**2. Перечислите методы сортировки, основанные на рекурсии?**

- Слиянием
- Быстрая


**3. В чем суть метода Шелла?**

Это по сути алгоритм вставками, только сначала он применяется к каждому n элементу, после к каждому k (k < n) и т.д. до 1(обязательно 1!). Количество таких проходов и сами приращения произвольные. Но желательно не степени двойки. Как сказано в файле наиболее эффективная каждый 9, 5, 3, 2 и 1. 


**4. В чем суть шейкерной сортировки?**

Это модифицированная сортировка пузырьком, только в ней когда элемент "всплывает", то элемент который был заменён "тонет".  То есть если грубо говорить то по сути выполняется одновременная сортировка пузырьком по возрастанию и по убыванию.

**5. В чем суть метода простых вставок?**

Алгоритм проходится по массиву слева-направо и двигает элемент влево до своего места (то есть до тех пор, пока элемент слева не будет меньше его, а элемент справа больше.

**6. В чем суть метода простым выбором?**

Похожий на метод вставок, но только мы начинаем слева-направо и вставляем на текущее место минимальный элемент из последовательности стоящей справа и так идём до последнего элемента, который уже стоит на своем месте.

**7. В чем суть сортировки слиянием?**

Массив рекурсивно делится на 2, до тех пор пока длина не станет равна 1, тогда два соседних массива сливаются в один по возрастанию. Специальный метод слияние работает только на отсортированных массивах, поэтому слияния начинаются с единичных массивов и заканчиваются исходными половинами.

**8. В чем суть быстрой сортировки?**

Алгоритм выбирает произвольный опорный элемент (случайно, либо какая-то конкретная позиция). И дальнейшее время работы зависит от того на сколько этот элемент близок к медиане последовательности. После выбора элемент алгоритм пробегается от начала до элемента, большего, либо равен опорному и после этого от конца до элемента меньшего либо равного опорному и меняет их местами и идет дальше до тех пор, пока они не пересекутся (счетчики пробежки).  После этого рекурсивно этот же алгоритм вызывается для полученных двух частей ( той что больше либа равна опорному и той что меньше либо равна опорному)

